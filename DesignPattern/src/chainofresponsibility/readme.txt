当出现处理一个问题，扯皮，或者踢皮球的时候，究竟哪个部门处理这个问题
并且问题发起者与问题解决这避免耦合在一起

责任链模式：
使多个对象都有可能处理请求，从而避免请求的发起者和接受者之间的耦合关系。将这些处理请求的
对象连成一个链，并沿着这个链处理请求，知道有一个对象处理它为止。

注意：在责任链模式中，很多的对象由每一个对象以及对其下家的引用连接起来形成一条链
	请求在这一条链上进行传递，直到链上的某一个对象处理了这个请求为止
	发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响
	客户端的情况下动态的重新组织链和分配责任
	
	
以下情况下使用responsibility链：
	1、有多个对象可以处理请求，哪个对象处理请求在运行时刻自动确定
	2、你想在不明确指定接受者的情况下，向多个对象中一个提交一个请求
	3、可动态指定一组对象处理器请求（过滤器就属于这一种）
	
模式的组成：
	抽象处理者角色（Handler:Approver）定义一个处理请求的接口和一个后继连接（可选）
	具体处理者角色（ConcreateHandler:President）处理它所负责的请求，可以访问后继者，如果
	可以处理请求则处理
	，否则将该请求转给后继者
	客户类（Client）向一个链上的具体处理者ConcreateHandler对象提交请求
	
responsibility的优缺点
	优点：降低耦合度，该模式使得一个对象无需知道自己会被哪一个对象所处理其请求。改对象只需知道
	这个请求可以被正确的处理。接收者和发送者之间没有对方明确的信息，且链中对象无需知道链中
	的结构。
	可简化对象之间的相互连接，只需保持一个对后继者的引用，而无需保存其他候选者的引用
	增强了给对象指派职责的灵活性，当在对象中分派职责时，职责连给你更多的灵活性。你可以通过在运行
	时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这中机制与静态的
	特例化处理对象的继承机制结合起来使用
	增加新的请求处理类更加的方便
	
responsibility的缺点
	缺点
	不能保证请求一定被接受，既然一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能
	到末端都得不到处理。一个请求有可能因该链没有被正确配置而没有被处理
	系统性能将受到一定影响，而且在进行代码调试时不太方便；可能造成循环调用
	
	